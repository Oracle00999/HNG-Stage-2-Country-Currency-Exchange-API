const express = require("express");
const axios = require("axios");
const db = require("./config/db");
const { createCanvas } = require("canvas");
const fs = require("fs").promises;
const fsSync = require("fs");
const path = require("path");

require("dotenv").config();

const app = express();
app.use(express.json());

const PORT = process.env.PORT || 3000;

// Auto-create tables on startup
async function initializeDatabase() {
  try {
    console.log("ðŸ”„ Initializing database tables...");
    const connection = await db.getConnection();

    await connection.execute(`
      CREATE TABLE IF NOT EXISTS countries (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        capital VARCHAR(255),
        region VARCHAR(255),
        population BIGINT NOT NULL,
        currency_code VARCHAR(10),
        exchange_rate DECIMAL(20, 6),
        estimated_gdp DECIMAL(30, 6),
        flag_url TEXT,
        last_refreshed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
      )
    `);

    console.log("âœ… Countries table created/verified");

    // Create indexes safely with error handling
    const indexQueries = [
      "DROP INDEX IF EXISTS idx_region ON countries",
      "CREATE INDEX idx_region ON countries(region)",
      "DROP INDEX IF EXISTS idx_currency_code ON countries",
      "CREATE INDEX idx_currency_code ON countries(currency_code)",
      "DROP INDEX IF EXISTS idx_estimated_gdp ON countries",
      "CREATE INDEX idx_estimated_gdp ON countries(estimated_gdp)",
      "DROP INDEX IF EXISTS idx_name ON countries",
      "CREATE INDEX idx_name ON countries(name)",
    ];

    for (const query of indexQueries) {
      try {
        await connection.query(query);
      } catch (err) {
        // Ignore errors for DROP INDEX IF EXISTS (if index doesn't exist)
        if (err.code !== "ER_BAD_INDEX" && err.code !== "ER_NO_SUCH_INDEX") {
          throw err;
        }
      }
    }

    connection.release();
    console.log("âœ… Database indexes created");
  } catch (error) {
    console.error("âŒ Database initialization failed:", error.message);
  }
}

// Initialize database when server starts
initializeDatabase();

// Global refresh timestamp
let lastRefreshTimestamp = null;

// Utility function to generate random number between min and max
const getRandomMultiplier = () => Math.floor(Math.random() * 1001) + 1000;

// Create cache directory if it doesn't exist
const ensureCacheDir = () => {
  const cacheDir = path.join(__dirname, "cache");
  if (!fsSync.existsSync(cacheDir)) {
    fsSync.mkdirSync(cacheDir, { recursive: true });
  }
  return cacheDir;
};

// Simple image generation without fancy graphics
async function generateSummaryImage() {
  try {
    const cacheDir = ensureCacheDir();
    const imagePath = path.join(cacheDir, "summary.png");

    // Get data from database
    const [topCountries] = await db.execute(
      "SELECT name, estimated_gdp FROM countries WHERE estimated_gdp IS NOT NULL ORDER BY estimated_gdp DESC LIMIT 5"
    );

    const [[{ total_countries }]] = await db.execute(
      "SELECT COUNT(*) as total_countries FROM countries"
    );

    const [[{ last_refresh }]] = await db.execute(
      "SELECT MAX(last_refreshed_at) as last_refresh FROM countries"
    );

    // Create canvas
    const canvas = createCanvas(600, 400);
    const ctx = canvas.getContext("2d");

    // Fill background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, 600, 400);

    // Add border
    ctx.strokeStyle = "#333333";
    ctx.lineWidth = 2;
    ctx.strokeRect(10, 10, 580, 380);

    // Title
    ctx.fillStyle = "#333333";
    ctx.font = "bold 20px Arial";
    ctx.fillText("COUNTRIES SUMMARY", 30, 40);

    // Total countries
    ctx.font = "16px Arial";
    ctx.fillText(`Total Countries: ${total_countries}`, 30, 80);

    // Last refresh
    const refreshTime = last_refresh
      ? new Date(last_refresh).toLocaleString()
      : "Never";
    ctx.fillText(`Last Updated: ${refreshTime}`, 30, 110);

    // Separator line
    ctx.beginPath();
    ctx.moveTo(30, 130);
    ctx.lineTo(570, 130);
    ctx.strokeStyle = "#cccccc";
    ctx.stroke();

    // Top countries header
    ctx.fillStyle = "#333333";
    ctx.font = "bold 16px Arial";
    ctx.fillText("Top 5 Countries by GDP:", 30, 160);

    // List top countries
    ctx.font = "14px Arial";
    let yPos = 190;

    topCountries.forEach((country, index) => {
      const gdpFormatted = country.estimated_gdp
        ? `$${parseFloat(country.estimated_gdp).toLocaleString()}`
        : "N/A";

      ctx.fillText(`${index + 1}. ${country.name}`, 50, yPos);
      ctx.fillText(gdpFormatted, 400, yPos);
      yPos += 30;
    });

    // Footer
    ctx.font = "12px Arial";
    ctx.fillStyle = "#666666";
    ctx.fillText("Generated by Countries API", 30, 380);

    // Save image
    const buffer = canvas.toBuffer("image/png");
    await fs.writeFile(imagePath, buffer);

    console.log("âœ… Summary image generated successfully at:", imagePath);
    return true;
  } catch (error) {
    console.error("âŒ Image generation failed:", error);
    return false;
  }
}

// POST /countries/refresh - FIXED DUPLICATE ISSUE
app.post("/countries/refresh", async (req, res) => {
  const connection = await db.getConnection();

  try {
    console.log("ðŸ”„ Starting countries refresh...");

    // Fetch countries data
    const countriesResponse = await axios.get(
      "https://restcountries.com/v2/all?fields=name,capital,region,population,flag,currencies",
      { timeout: 15000 }
    );

    // Fetch exchange rates
    const exchangeResponse = await axios.get(
      "https://open.er-api.com/v6/latest/USD",
      { timeout: 15000 }
    );

    const countries = countriesResponse.data;
    const exchangeRates = exchangeResponse.data.rates;

    console.log(
      `ðŸ“Š Fetched ${countries.length} countries and ${
        Object.keys(exchangeRates).length
      } exchange rates`
    );

    await connection.beginTransaction();

    // TRUNCATE table first to avoid duplicates, or use UPSERT
    console.log("ðŸ—‘ï¸ Clearing existing countries data...");
    await connection.execute("DELETE FROM countries");

    let inserted = 0;
    let skipped = 0;

    for (const country of countries) {
      let currencyCode = null;
      let exchangeRate = null;
      let estimatedGdp = null;

      // Handle currency logic
      if (
        country.currencies &&
        country.currencies.length > 0 &&
        country.currencies[0].code
      ) {
        currencyCode = country.currencies[0].code;

        if (currencyCode && exchangeRates[currencyCode]) {
          exchangeRate = exchangeRates[currencyCode];
          const randomMultiplier = getRandomMultiplier();
          estimatedGdp = (country.population * randomMultiplier) / exchangeRate;
        }
      }

      try {
        // INSERT with ON DUPLICATE KEY UPDATE (though we cleared table, this is safe)
        await connection.execute(
          `INSERT INTO countries 
                     (name, capital, region, population, currency_code, exchange_rate, estimated_gdp, flag_url) 
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?) 
                     ON DUPLICATE KEY UPDATE
                     capital = VALUES(capital), 
                     region = VALUES(region), 
                     population = VALUES(population),
                     currency_code = VALUES(currency_code),
                     exchange_rate = VALUES(exchange_rate),
                     estimated_gdp = VALUES(estimated_gdp),
                     flag_url = VALUES(flag_url),
                     last_refreshed_at = NOW()`,
          [
            country.name,
            country.capital || null,
            country.region || null,
            country.population,
            currencyCode,
            exchangeRate,
            estimatedGdp,
            country.flag || null,
          ]
        );
        inserted++;
      } catch (insertError) {
        // If duplicate still occurs, update instead
        if (insertError.code === "ER_DUP_ENTRY") {
          await connection.execute(
            `UPDATE countries SET 
                         capital = ?, region = ?, population = ?, currency_code = ?, 
                         exchange_rate = ?, estimated_gdp = ?, flag_url = ?, last_refreshed_at = NOW() 
                         WHERE name = ?`,
            [
              country.capital || null,
              country.region || null,
              country.population,
              currencyCode,
              exchangeRate,
              estimatedGdp,
              country.flag || null,
              country.name,
            ]
          );
          skipped++;
        } else {
          throw insertError;
        }
      }

      if ((inserted + skipped) % 50 === 0) {
        console.log(
          `âœ… Processed ${inserted + skipped}/${countries.length} countries`
        );
      }
    }

    await connection.commit();
    lastRefreshTimestamp = new Date().toISOString();

    console.log(
      `âœ… Database updated: ${inserted} inserted, ${skipped} updated`
    );

    // Generate summary image
    console.log("ðŸ–¼ï¸ Generating summary image...");
    const imageGenerated = await generateSummaryImage();

    res.json({
      message: "Countries data refreshed successfully",
      total_countries: inserted + skipped,
      image_generated: imageGenerated,
      last_refreshed_at: lastRefreshTimestamp,
    });
  } catch (error) {
    await connection.rollback();
    console.error("âŒ Refresh error:", error);

    if (error.code === "ECONNABORTED" || error.response?.status >= 500) {
      return res.status(503).json({
        error: "External data source unavailable",
        details: "Could not fetch data from external API",
      });
    }

    res.status(500).json({ error: "Internal server error" });
  } finally {
    connection.release();
  }
});

// GET /countries/image
app.get("/countries/image", (req, res) => {
  try {
    const imagePath = path.join(__dirname, "cache", "summary.png");

    console.log("ðŸ“ Looking for image at:", imagePath);

    if (fsSync.existsSync(imagePath)) {
      console.log("âœ… Image found, serving...");

      res.setHeader("Content-Type", "image/png");
      res.setHeader("Content-Disposition", 'inline; filename="summary.png"');

      const imageBuffer = fsSync.readFileSync(imagePath);
      res.send(imageBuffer);
    } else {
      console.log("âŒ Image not found at:", imagePath);
      res.status(404).json({
        error: "Summary image not found",
        message:
          "Please run POST /countries/refresh first to generate the image",
      });
    }
  } catch (error) {
    console.error("âŒ Image serving error:", error);
    res
      .status(500)
      .json({ error: "Internal server error while serving image" });
  }
});

// GET /countries
app.get("/countries", async (req, res) => {
  try {
    const { region, currency, sort } = req.query;

    let query = "SELECT * FROM countries WHERE 1=1";
    const params = [];

    if (region) {
      query += " AND region = ?";
      params.push(region);
    }

    if (currency) {
      query += " AND currency_code = ?";
      params.push(currency);
    }

    if (sort) {
      if (sort === "gdp_desc") {
        query += " ORDER BY estimated_gdp DESC";
      } else if (sort === "gdp_asc") {
        query += " ORDER BY estimated_gdp ASC";
      } else if (sort === "name_asc") {
        query += " ORDER BY name ASC";
      } else if (sort === "name_desc") {
        query += " ORDER BY name DESC";
      }
    }

    const [countries] = await db.execute(query, params);

    console.log(`ðŸ“Š Returning ${countries.length} countries`);

    res.json(
      countries.map((country) => ({
        ...country,
        estimated_gdp: country.estimated_gdp
          ? parseFloat(country.estimated_gdp)
          : null,
        exchange_rate: country.exchange_rate
          ? parseFloat(country.exchange_rate)
          : null,
      }))
    );
  } catch (error) {
    console.error("Get countries error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// GET /status
app.get("/status", async (req, res) => {
  try {
    const [[{ total_countries }]] = await db.execute(
      "SELECT COUNT(*) as total_countries FROM countries"
    );

    const [[{ last_refresh }]] = await db.execute(
      "SELECT MAX(last_refreshed_at) as last_refresh FROM countries"
    );

    console.log(
      `ðŸ“ˆ Status: ${total_countries} countries, last refresh: ${last_refresh}`
    );

    res.json({
      total_countries,
      last_refreshed_at: last_refresh || lastRefreshTimestamp,
    });
  } catch (error) {
    console.error("Status error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// GET /countries/:name
app.get("/countries/:name", async (req, res) => {
  try {
    const { name } = req.params;

    const [countries] = await db.execute(
      "SELECT * FROM countries WHERE name = ?",
      [name]
    );

    if (countries.length === 0) {
      return res.status(404).json({ error: "Country not found" });
    }

    const country = countries[0];
    res.json({
      ...country,
      estimated_gdp: country.estimated_gdp
        ? parseFloat(country.estimated_gdp)
        : null,
      exchange_rate: country.exchange_rate
        ? parseFloat(country.exchange_rate)
        : null,
    });
  } catch (error) {
    console.error("Get country error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.delete("/countries/:name", async (req, res) => {
  try {
    const { name } = req.params;

    const [result] = await db.execute("DELETE FROM countries WHERE name = ?", [
      name,
    ]);

    if (result.affectedRows === 0) {
      return res.status(404).json({ error: "Country not found" });
    }

    res.json({ message: "Country deleted successfully" });
  } catch (error) {
    console.error("Delete country error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// Auto-refresh on startup (optional for production)
async function autoRefresh() {
  try {
    console.log("ðŸ”„ Auto-refreshing countries data on startup...");
    const response = await axios.post(
      `${
        process.env.APP_URL || "http://localhost:${PORT}"
      }${"/countries/refresh"}`
    );
    console.log("âœ… Auto-refresh completed:", response.data);
  } catch (error) {
    console.error("âŒ Auto-refresh failed:", error.message);
  }
}

// Call auto-refresh after server starts
app.listen(PORT, async () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
  ensureCacheDir();
  console.log("âœ… Cache directory ready");

  // Only auto-refresh if not in development or if desired
  if (process.env.NODE_ENV !== "development") {
    await autoRefresh();
  }
});

// Initialize server
app.listen(PORT, async () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
  ensureCacheDir();
  console.log("âœ… Cache directory ready");

  // Wait for 5 seconds to ensure DB is ready and routes are loaded
  await new Promise((r) => setTimeout(r, 5000));

  // Only auto-refresh if not in development or if desired
  if (process.env.NODE_ENV !== "development") {
    await autoRefresh();
  }
});
